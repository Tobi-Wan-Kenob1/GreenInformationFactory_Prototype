name: Upload release payload to Zenodo

# Only this workflow reacts to "upload" tags
on:
  workflow_dispatch:
    inputs:
      title:
        description: "Zenodo title"
        required: true
        default: "GreenInformationFactory – Processed Data, Model & Performance"
      description:
        description: "Zenodo description"
        required: true
        default: "Train/test splits, trained model(s), and evaluation figure. Raw data: 10.5281/zenodo.16256961."
      community:
        description: "Zenodo community identifier"
        required: true
        default: "biofairnet"
      creator:
        description: "Creator (Surname, Name)"
        required: true
        default: "Rosnitschek, Tobias"
      affiliation:
        description: "Affiliation"
        required: true
        default: "University of Bayreuth"
      orcid:
        description: "ORCID (leave empty if none)"
        required: true
        default: ""
      keyword1:
        description: "Keyword 1"
        required: true
        default: "FAIR"
      keyword2:
        description: "Keyword 2"
        required: true
        default: "machine learning"
      keyword3:
        description: "Keyword 3"
        required: true
        default: "circular economy"
      license_id:
        description: "License identifier"
        required: true
        default: "MIT"
      use_sandbox:
        description: "Use Zenodo SANDBOX (recommended; safe for tests)"
        required: true
        default: "true"    # ← default: sandbox
  push:
    tags:
      - "zenodo-ul-*"

permissions:
  contents: write

concurrency:
  group: zenodo-upload-${{ github.ref }}
  cancel-in-progress: true

jobs:
  upload:
    # Guard: only run for upload tags or manual runs
    if: startsWith(github.ref_name, 'zenodo-ul-') || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    env:
      PAYLOAD_DIR: notebooks/release_payload
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure jq
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

      - name: Resolve parameters (including sandbox flag)
        id: cfg
        run: |
          # Default to sandbox unless explicitly set to "false"
          USE_SANDBOX_INPUT="${{ github.event.inputs.use_sandbox }}"
          if [ "${USE_SANDBOX_INPUT}" = "false" ] || [ "${USE_SANDBOX_INPUT}" = "False" ]; then
            USE_SANDBOX="false"
          else
            USE_SANDBOX="true"
          fi
          echo "use_sandbox=$USE_SANDBOX" >> $GITHUB_OUTPUT
          echo "Using sandbox? $USE_SANDBOX"

      - name: Verify payload directory and list files
        run: |
          echo "Using payload dir: ${PAYLOAD_DIR}"
          if [ ! -d "${PAYLOAD_DIR}" ]; then
            echo "::error ::Payload directory '${PAYLOAD_DIR}' does not exist at repo root."
            exit 1
          fi
          file_count=$(find "${PAYLOAD_DIR}" -maxdepth 1 -type f | wc -l | tr -d ' ')
          if [ "${file_count}" = "0" ]; then
            echo "::error ::No files found in '${PAYLOAD_DIR}'. Place your CSVs/model/plots there and commit."
            exit 1
          fi
          echo "Found ${file_count} file(s):"
          ls -lah "${PAYLOAD_DIR}"

      - name: Pick Zenodo base URL and token
        id: endpoints
        env:
          ZENODO_TOKEN: ${{ secrets.ZENODO_TOKEN }}
          ZENODO_SANDBOX_TOKEN: ${{ secrets.ZENODO_SANDBOX_TOKEN }}
        run: |
          if [ "${{ steps.cfg.outputs.use_sandbox }}" = "true" ]; then
            BASE="https://sandbox.zenodo.org"
            TOKEN="${ZENODO_SANDBOX_TOKEN}"
          else
            BASE="https://zenodo.org"
            TOKEN="${ZENODO_TOKEN}"
          fi

          if [ -z "$TOKEN" ]; then
            echo "::error ::Missing API token. For sandbox set repo secret ZENODO_SANDBOX_TOKEN; for production set ZENODO_TOKEN."
            exit 1
          fi

          echo "base=$BASE"   >> $GITHUB_OUTPUT
          echo "token=$TOKEN" >> $GITHUB_OUTPUT
          echo "API base: $BASE"

      - name: Create deposition
        id: dep
        run: |
          BASE="${{ steps.endpoints.outputs.base }}"
          TOKEN="${{ steps.endpoints.outputs.token }}"

          META=$(jq -n \
            --arg title "${{ github.event.inputs.title }}" \
            --arg desc  "${{ github.event.inputs.description }}" \
            --arg comm  "${{ github.event.inputs.community }}" \
            --arg creator "${{ github.event.inputs.creator }}" \
            --arg affil   "${{ github.event.inputs.affiliation }}" \
            --arg orcid   "${{ github.event.inputs.orcid }}" \
            --arg kw1     "${{ github.event.inputs.keyword1 }}" \
            --arg kw2     "${{ github.event.inputs.keyword2 }}" \
            --arg kw3     "${{ github.event.inputs.keyword3 }}" \
            --arg lic     "${{ github.event.inputs.license_id }}" \
            '{
               metadata: {
                 title: $title,
                 upload_type: "dataset",
                 description: $desc,
                 creators: (
                   if ($orcid | length) > 0 then
                     [{name:$creator, affiliation:$affil, orcid:$orcid}]
                   else
                     [{name:$creator, affiliation:$affil}]
                   end
                 ),
                 communities: [{identifier:$comm}],
                 keywords: [$kw1, $kw2, $kw3],
                 related_identifiers: [
                   {identifier:"10.5281/zenodo.16256961", relation:"isDerivedFrom", scheme:"doi"}
                 ],
                 access_right: "open",
                 license: $lic
               }
             }')

          echo "Creating deposition…"
          RES=$(curl -sS -X POST "$BASE/api/deposit/depositions" \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer $TOKEN" \
              -d "$META")
          echo "$RES" > dep.json

          dep_id=$(jq -r '.id // empty' dep.json)
          bucket=$(jq -r '.links.bucket // empty' dep.json)
          html=$(jq -r '.links.html // empty' dep.json)

          if [ -z "$dep_id" ] || [ -z "$bucket" ]; then
            echo "::error ::Failed to create deposition. Response:"
            cat dep.json
            exit 1
          fi

          echo "id=$dep_id"     >> $GITHUB_OUTPUT
          echo "bucket=$bucket" >> $GITHUB_OUTPUT
          echo "html=$html"     >> $GITHUB_OUTPUT

      - name: Upload files
        run: |
          set -euo pipefail
          TOKEN="${{ steps.endpoints.outputs.token }}"
          echo "Uploading from ${PAYLOAD_DIR}…"
          while IFS= read -r -d '' f; do
            base=$(basename "$f")
            echo "Uploading: $base"
            curl -sS --fail -H "Authorization: Bearer $TOKEN" \
                 --upload-file "$f" "${{ steps.dep.outputs.bucket }}/$base"
          done < <(find "${PAYLOAD_DIR}" -maxdepth 1 -type f -print0)

      - name: Publish deposition
        id: publish
        run: |
          BASE="${{ steps.endpoints.outputs.base }}"
          TOKEN="${{ steps.endpoints.outputs.token }}"
          echo "Publishing deposition ${{ steps.dep.outputs.id }}…"
          RES=$(curl -sS -X POST "$BASE/api/deposit/depositions/${{ steps.dep.outputs.id }}/actions/publish" \
                 -H "Authorization: Bearer $TOKEN")
          echo "$RES" > pub.json

          doi=$(jq -r '.metadata.doi // empty' pub.json)
          record=$(jq -r '.links.record_html // empty' pub.json)

          if [ -z "$doi" ] || [ -z "$record" ]; then
            echo "::error ::Publish step failed. Response:"
            cat pub.json
            exit 1
          fi

          echo "doi=$doi"    >> $GITHUB_OUTPUT
          echo "record=$record" >> $GITHUB_OUTPUT

      - name: Output links
        run: |
          echo "Record: ${{ steps.publish.outputs.record }}"
          echo "DOI:    ${{ steps.publish.outputs.doi }}"
